# Индивидуальное домашнее задание по АВС #4
## Сизикин Владислав Олегович (БПИ218), Вариант 18

## Задача:
    Задача о болтунах. N болтунов имеют телефоны. Они либо ждут звонков, либо звонят друг другу, чтобы побеседовать. 
    Если телефон случайного абонента занят, болтун будет звонить другому абоненту, пока ему кто-нибудь не ответит. 
    Побеседовав некоторое время, болтун или ждет звонка, или звонит на другой случайный номер. 
    Создать многопоточное приложение, моделирующее поведение болтунов. Для решения задачи использовать мьютексы.
    
## Задача выполнена на 9 баллов (в качестве пункта на 9 был выбрал второй вариант с использованием openMP)
    
## Файлы с кодом: [pthread](code/pthread_main.cpp) и [openMP](code/openmp_main.cpp)

## Формат входных данных: 
Через параметры входной строки передаются параметры:

1. Ввод данных из консоли

        {executable_filename} -c {number}
    
        Например: ./main -c 7

3. Ввод данных из файла

        {executable_filename} -f {input_filename} {output_filename}
    
        Например: ./main -f in.txt out.txt
  
3. Генерация рандомных входных данных

        {executable_filename} -r {left_range_number} {right_range_number}
        
        Например: ./main -r 2 7
        
        В таком случае сгененируется число от 2 до 7 (включительно)
     
#### При работе со входным файлом: в файл вводится натуральное число - количество собеседников

    1. 1 <= x <= 100

#### Пример:

    5
    
## Формат вывода:

    {call_status} {first_person} {second_person} at {timing}
    
### В файле [out.txt](code/out.txt) есть пример вывода при входных данных [in.txt](code/in.txt)
    
### Запуск приложения
#### Запуск программы с использованием `pthread`

 - Компиляция: `g++ -lpthread pthread_main.cpp -std=c++17 -o main`

При консольном вводе или случайном без указания файла, все события будут выводиться в консоль. Если же указан выходной файл, то все события будут записываться во временный вектор, а при правильной остановке программы (через ввод `q`) запипишутся в файл.

#### Запуск программы с использованием `openMP`

 - Компиляция: `g++-12 -fopenmp -std=c++17 openmp_main.cpp -o main`

#### Остановка программы

Производится вводом 'q' в консоль

В программе используются 3 * n + 1 потоков: по 3 на каждого болтуна (поток, ищущий собеседника и инициирующий звонок; поток, принимающий звонок; поток, решающий, сбросить текущий звонок или продолжить) + 1 для отслеживания ввода 'q' для завершения программы

### О программе (модель)
Для решения задачи была выбрана модель с общей памятью, где каждый поток имеет возможность читать/записывать в нее. В моем случае это `vector<Caller> callers`. Для избежания ситуаций неуправляемого изменения одних и тех же общих данных несколькими потоками и их несогласованного поведения были использованы мьютексы, как требовалось в задании. Перед чтением/записью доступ блокировался через `pthread_mutex_lock(&mutex);` а затем освобождался через `pthread_mutex_unlock(&mutex);`. Я разделил потоки на обработчики исходящих, входящих и текущих(происходящих в данный момент) звонков. Также был добавлен поток для завершения программы (`key_thread`).

### О программе (поведение сущностей)
Каждый болтун выбирает случайного собеседника и пытается дозвониться ему, если ему удается, то он болтает с другим болтуном некоторое время, после чего ищет себе нового собеседника или получает звонок от другого болтуна.

### О программе (алгоритм)
Каждый болтун (`Caller`) имеет свой статус (звонит, в звонке, ожидает) и свой индекс, который могут видеть другие болтуны. При любом событии этот статус изменяется. Все статусы лежат в общем векторе болтунов `callers`, откуда все берут информацию. В начале звонка болтун в потоке `process_calls` проверяет что: он не занят и планируемый собеседник не занят. Затем он изменяет статусы. После чего поток `process_answer` проверяет статусы болтунов и начинает звонок, который длится случайное время. После окончаения статусы обновляются и болтуны становятся доступными для следующих итераций.

### Особенности openMP
В программе вместо мьютексов использовалась критическая секция `#pragma omp critical`. Также обработка потоков происходит в одной функции, поведение которой зависит от номера потока.

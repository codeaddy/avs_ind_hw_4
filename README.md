# Индивидуальное домашнее задание по АВС #2
## Сизикин Владислав Олегович (БПИ218), Вариант 9

## Задача:
    Задача о болтунах. N болтунов имеют телефоны. Они либо ждут звонков, либо звонят друг другу, чтобы побеседовать. 
    Если телефон случайного абонента занят, болтун будет звонить другому абоненту, пока ему кто-нибудь не ответит. 
    Побеседовав некоторое время, болтун или ждет звонка, или звонит на другой случайный номер. 
    Создать многопоточное приложение, моделирующее поведение болтунов. Для решения задачи использовать мьютексы.
    
## Файлы с кодом: [pthread](code/pthread_main.cpp) и [openMP](code/openmp_main.cpp)

## Формат входных данных: 
Через параметры входной строки передаются параметры:

1. Ввод данных из консоли

        {executable_filename} -c {number}
    
        Например: ./main -c 7

3. Ввод данных из файла

        {executable_filename} -f {input_filename} {output_filename}
    
        Например: ./main -f in.txt out.txt
  
3. Генерация рандомных входных данных

        {executable_filename} -r {left_range_number} {right_range_number}
        
        Например: ./main -r 2 7
        
        В таком случае сгененируется число от 2 до 7 (включительно)
     
#### При работе со входным файлом: в файл вводится натуральное число - количество собеседников

    1. 1 <= x <= 100

#### Пример:

    5
    
## Формат вывода:

    {call_status} {first_person} {second_person} at {timing}
    
### Запуск приложения
#### Запуск программы с использованием `pthread`

 - Компиляция: `g++ pthread_main.cpp -o main -lpthread`

При консольном вводе или случайном без указания файла, все события будут выводиться в консоль. Если же указан выходной файл, то все события будут записываться во временный вектор, а при правильной остановке программы (через ввод `q`) запипишутся в файл.

#### Запуск программы с использованием `openMP`

 - Компиляция: `g++ openmp_main.cpp -o main -fopenmp`

В программе используются 3 * n + 1 потоков: по 3 на каждого болтуна + 1 для отслеживания ввода 'q' для завершения программы

### О программе (модель)
Для решения задачи была выбрана модель с общей памятью, где каждый поток имеет возможность читать/записывать в нее. В моем случае это `vector<Caller> callers`. Для избежания ситуаций неуправляемого изменения одних и тех же общих данных несколькими потоками и их несогласованного поведения были использованы мьютексы, как требовалось в задании. Перед чтением/записью доступ блокировался через `pthread_mutex_lock(&mutex);` а затем освобождался через `pthread_mutex_unlock(&mutex);`. Я разделил потоки на обработчики исходящих, входящих и текущих(происходящих в данный момент) звонков. Также был добавлен поток для завершения программы (`key_press_thread`).

### О программе (поведение сущностей)
Каждый болтун выбирает случайного собеседника и пытается дозвониться ему, если ему удается, то он болтает с другим болтуном некоторое время, после чего ищет себе нового собеседника или получает звонок от другого болтуна.

### О программе (алгоритм)
Каждый болтун (`Caller`) имеет свой статус (звонит, в звонке, ожидает) и свой индекс, который могут видеть другие болтуны. При любом событии этот статус изменяется. Все статусы лежат в общем векторе болтунов `callers`, откуда все берут информацию. В начале звонка болтун в потоке `process_calls` проверяет что: он не занят и планируемый собеседник не занят. Затем он изменяет статусы. После чего поток `process_answer` проверяет статусы болтунов и начинает звонок, который длится случайное время. После окончаения статусы обновляются и болтуны становятся доступными для следующих итераций.

### Особенности openMP
В программе вместо мьютексов использовалась критическая секция `#pragma omp critical`. Также обработка потоков происходит в одной функции, поведение которой зависит от номера потока.
